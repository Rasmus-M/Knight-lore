* ---------------------------------------------------------------------------

       copy "font.a99"
       copy "locations.a99"
       copy "block-types.a99"
       copy "background-types.a99"
       copy "special-objects.a99"

*      Sprites are flipped and mirrored on the fly
       copy "sprites.a99"

* Update sprite jump table
       copy "update-sprite-jump-table.a99"

* ---------------------------------------------------------------------------
sprite_scratchpad:
       byte >8A, >00, >00, >00, >00, >00, >00, >00, >00, >00, >00, >00, >00, >00, >00, >00
       byte >00, >00, >00, >00, >00, >00, >00, >00, >03, >01, >E8, >A0, >00, >00, >00, >00
* ---------------------------------------------------------------------------
objects_required:
       byte 0, 1, 2, 3, 4, 5, 6, 3
       byte 5, 0, 6, 1, 2, 4
* ---------------------------------------------------------------------------
render_list:
       byte >FF
       byte >FF
       byte >FF
       byte >FF
       byte >FF
       byte >FF
       byte >FF
       byte >FF

* ---------------------------------------------------------------------------
       even
* ---------------------------------------------------------------------------

       copy "pickup-drop-objects.a99"

* =============== S U B R O U T I N E =======================================
*
print_days:
       mov  r11,*sp+
;RAM:BC66 21 E2 D9                    ld      hl, # vidbuf+0xEF                       ; (120,7)
       li   hl,vidbuf+>00EF
;RAM:BC69 11 B9 5B                    ld      de, #days
       li   de,days
;RAM:BC6C 06 01                       ld      b, #1
       movb one,b
;RAM:BC6E CD AE BC                    call    print_BCD_number
       bl   @print_BCD_number
;RAM:BC71 21 EF 5A                    ld      hl, # zx_aram+0x2EF                     ; attribute memory
       li   hl,zx_aram+>02EF
;RAM:BC74 36 47                       ld      (hl), #0x47 ; 'G'
;RAM:BC76 2C                          inc     l
;RAM:BC77 36 47                       ld      (hl), #0x47 ; 'G'
       li   a,>4700
       li   bc,>0201
       bl   @fill_color_window
;RAM:BC79 C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function print_days
*
* =============== S U B R O U T I N E =======================================
*
print_lives_gfx:
       mov  r11,*sp+
;RAM:BC7A DD 21 DB BF                 ld      ix, #sprite_scratchpad
       li   ix,sprite_scratchpad
;RAM:BC7E DD 36 00 8C                 ld      0(ix), #0x8C ; '�'                      ; sprite index
       movb @b8ch,*ix
;RAM:BC82 DD 36 07 00                 ld      7(ix), #0                               ; clear flags
       szcb mone,@7(ix)
;RAM:BC86 DD 36 1A 10                 ld      26(ix), #16                             ; pixel X
       movb @b10h,@26(ix)
;RAM:BC8A DD 36 1B 20                 ld      27(ix), #32                             ; pixel Y
       movb @b20h,@27(ix)
;RAM:BC8E CD 18 D7                    call    print_sprite
       bl   @print_sprite
;RAM:BC91 3E 47                       ld      a, #0x47 ; 'G'
       movb @b47h,a
;RAM:BC93 11 42 5A                    ld      de, # zx_aram+0x242
       li   hl,zx_aram+>0242
;RAM:BC96 06 02                       ld      b, #2
       li   bc,>0201
;RAM:BC98 CD 09 D5                    call    fill_DE
       bl   @fill_color_window
;RAM:BC9B 11 62 5A                    ld      de, # zx_aram+0x262
       li   hl,zx_aram+>0262
;RAM:BC9E 06 04                       ld      b, #4
       li   bc,>0401
;RAM:BCA0 C3 09 D5                    jp      fill_DE
       bl   @fill_color_window
*      Return
       dect sp
       mov  *sp,r11
       rt
*
* End of function print_lives_gfx
*
* =============== S U B R O U T I N E =======================================
*
print_lives:
;RAM:BCA3 11 BA 5B                    ld      de, #lives                              ; ptr number
       li   de,lives
;RAM:BCA6 06 01                       ld      b, #1                                   ; 1 byte (2 BCD digits)
       movb one,b
;RAM:BCA8 21 D7 DD                    ld      hl, # vidbuf+0x4E4                      ; screen buffer location
       li   hl,vidbuf+>04E4
;RAM:BCAB C3 AE BC                    jp      print_BCD_number
       b    @print_BCD_number
*
* End of function print_lives
*
* =============== S U B R O U T I N E =======================================
*
display_day:
       mov  r11,*sp+
;RAM:BCCA 3A AD 5B                    ld      a, (curr_room_attrib)                   ; attribute
       movb @curr_room_attrib,a
;RAM:BCCD 2F                          cpl
       inv  a
;RAM:BCCE C6 02                       add     a, #2
       ab   @b02h,a
;RAM:BCD0 E6 07                       and     #7
       andi a,>0700
;RAM:BCD2 F6 40                       or      #0x40 ; '@'                             ; bright on
       ori  a,>4000
;RAM:BCD4 32 E7 BC                    ld      (day_txt), a
       movb a,@day_txt
;RAM:BCD7 21 EC BC                    ld      hl, #day_font
       li   hl,day_font
;RAM:BCDA 22 C7 5B                    ld      (gfxbase_8x8), hl                       ; set print routine font
       mov  hl,@gfxbase_8x8
;RAM:BCDD 11 E7 BC                    ld      de, #day_txt
       li   de,day_txt
;RAM:BCE0 21 70 0F                    ld      hl, #0xF70                              ; screen location
       li   hl,>0f70
;RAM:BCE3 E5                          push    hl
       mov  hl,*sp+
;RAM:BCE4 C3 4C BE                    jp      print_text
       b    @print_text
* ---------------------------------------------------------------------------
day_txt:
       byte >00, >00, >01, >02, >83
       byte >00 ; Added one byte for word alignment
day_font:
       byte >06, >07, >06, >06, >06, >06, >06, >0F
       byte >00, >01, >82, >C6, >64, >6C, >6D, >C6
       byte >C8, >C6, >E1, >60, >60, >E0, >64, >63
       byte >60, >60, >60, >E0, >60, >40, >C0, >80
*
* End of function display_day
*
* =============== S U B R O U T I N E =======================================
*
display_panel:
       mov  r11,*sp+
;RAM:D255 DD 21 DB BF                 ld      ix, #sprite_scratchpad
       li   ix,sprite_scratchpad
;RAM:D259 21 7E D2                    ld      hl, #panel_data
       li   hl,panel_data
;RAM:D25C CD 37 D2                    call    transfer_sprite
       bl   @transfer_sprite
;RAM:D25F 11 10 F8                    ld      de, #0xF810                             ; x+=16,y-=8
       li   de,>F810
;RAM:D262 06 05                       ld      b, #5                                   ; 5 sprites
       movb @b05h,b
;RAM:D264 CD E4 BE                    call    multiple_print_sprite
       bl   @multiple_print_sprite
;RAM:D267 CD 4C D2                    call    transfer_sprite_and_print
       bl   @transfer_sprite_and_print
;RAM:D26A CD 4C D2                    call    transfer_sprite_and_print
       bl   @transfer_sprite_and_print
;RAM:D26D CD 37 D2                    call    transfer_sprite
       bl   @transfer_sprite
;RAM:D270 11 10 08                    ld      de, #0x810                              ; x+=16,y+=8
       li   de,>0810
;RAM:D273 06 05                       ld      b, #5                                   ; 5 sprites
       movb @b05h,b
;RAM:D275 CD E4 BE                    call    multiple_print_sprite
       bl   @multiple_print_sprite
;RAM:D278 CD 4C D2                    call    transfer_sprite_and_print
       bl   @transfer_sprite_and_print
;RAM:D27B C3 4C D2                    jp      transfer_sprite_and_print
       b    @transfer_sprite_and_print_1
* ---------------------------------------------------------------------------
panel_data:
       byte >86, >00, >10, >34
       byte >87, >00, >F0, >00
       byte >88, >00, >90, >04
       byte >86, >40, >A0, >14
       byte >87, >40, >00, >00
       byte >88, >40, >60, >04
*
* End of function display_panel
*
* =============== S U B R O U T I N E =======================================
*
colour_panel:
       mov  r11,*sp+
;RAM:D2EF AF                          xor     a
       clr  a
;RAM:D2F0 21 B6 5A                    ld      hl, # zx_aram+0x2B6
       li   hl,zx_aram+>02B6
;RAM:D2F3 01 03 01                    ld      bc, #0x103                              ; 1 bytes, 3 lines
       li   bc,>0103
;RAM:D2F6 CD 15 C5                    call    fill_window
       bl   @fill_color_window
;RAM:D2F9 21 BD 5A                    ld      hl, # zx_aram+0x2BD
       li   hl,zx_aram+>02BD
;RAM:D2FC 01 03 01                    ld      bc, #0x103                              ; 1 byte, 3 lines
       li   bc,>0103
;RAM:D2FF CD 15 C5                    call    fill_window
       bl   @fill_color_window
;RAM:D302 3E 42                       ld      a, #0x42 ; 'B'
       li   a,>4200
;RAM:D304 21 97 5A                    ld      hl, # zx_aram+0x297
       li   hl,zx_aram+>0297
;RAM:D307 01 04 06                    ld      bc, #0x604                              ; 6 bytes, 4 lines
       li   bc,>0604
;RAM:D30A C3 15 C5                    jp      fill_window
       dect sp
       mov  *sp,r11
       b    @fill_color_window
*
* End of function colour_panel
*
* =============== S U B R O U T I N E =======================================
*
colour_sun_moon:
       li   a,>4600
;RAM:D30D 3A 4D C4                    ld      a, (sun_moon_scratchpad)                ; graphic_no
       movb @sun_moon_scratchpad,b
;RAM:D310 E6 01                       and     #1                                      ; sun?
       andi b,>0100
;RAM:D312 3E 46                       ld      a, #0x46 ; 'F'                          ; attribute
;RAM:D314 28 01                       jr      Z, loc_D317                             ; yes, skip
       jeq  loc_D317
;RAM:D316 3C                          inc     a
       ab   one,a
loc_D317:                                                                             ; attribute memory
;RAM:D317 21 B8 5A                    ld      hl, # zx_aram+0x2B8
       li   hl,zx_aram+>02B8
;RAM:D31A 01 02 04                    ld      bc, #0x402                              ; 4 bytes, 2 lines
       li   bc,>0402
;RAM:D31D C3 15 C5                    jp      fill_window
       b    @fill_color_window
*
* End of function colour_sun_moon
*
* =============== S U B R O U T I N E =======================================
*
* HL = screen buffer address
* DE = ptr number to print (BCD)
* B  = number of bytes (BCD digit pairs)
*
print_BCD_number:
       mov  r11,*sp+
;RAM:BCAE E5                          push    hl
print_BCD_number_1:
       mov  hl,*sp+
;RAM:BCAF 21 08 61                    ld      hl, #font
       li   hl,font
;RAM:BCB2 22 C7 5B                    ld      (gfxbase_8x8), hl
       mov  hl,@gfxbase_8x8
;RAM:BCB5 E1                          pop     hl
       dect sp
       mov  *sp,hl
loc_BCB6:
;RAM:BCB6 1A                          ld      a, (de)                                 ; get number
       movb *de,a
;RAM:BCB7 0F                          rrca
;RAM:BCB8 0F                          rrca
;RAM:BCB9 0F                          rrca
;RAM:BCBA 0F                          rrca
       srl  a,4
;RAM:BCBB E6 0F                       and     #0xF                                    ; high digit
       andi a,>0f00
;RAM:BCBD CD 7F BE                    call    print_8x8
       bl   @print_8x8
print_BCD_lsd:
;RAM:BCC0 1A                          ld      a, (de)                                 ; get number
       movb *de,a
;RAM:BCC1 E6 0F                       and     #0xF                                    ; low digit
       andi a,>0f00
;RAM:BCC3 CD 7F BE                    call    print_8x8
       bl   @print_8x8
;RAM:BCC6 13                          inc     de                                      ; next byte address
       inc  de
;RAM:BCC7 10 ED                       djnz    loc_BCB6                                ; loop through all bytes
       sb   one,b
       jne  loc_BCB6
;RAM:BCC9 C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function print_BCD_number
*
* =============== S U B R O U T I N E =======================================
*
print_text_std_font:
       mov  r11,*sp+
;RAM:BE45 E5                          push    hl
       mov  hl,*sp+
;RAM:BE46 21 08 61                    ld      hl, #font
       li   hl,font
;RAM:BE49 22 C7 5B                    ld      (gfxbase_8x8), hl
       mov   hl,@gfxbase_8x8
*
* de: address of text
* screen location pushed to stack
* @gfxbase_8x8 contains fint address
*
print_text:
;RAM:BE4C C1                          pop     bc                                      ; pop screen location
       dect sp
       mov  *sp,bc
;RAM:BE4D C5                          push    bc
       mov  bc,*sp+
;RAM:BE4E CD 11 D8                    call    calc_vidbuf_addr
       bl   @calc_vidbuf_addr
;RAM:BE51 69                          ld      l, c
;RAM:BE52 60                          ld      h, b                                    ; HL = bitmap buffer address
       mov  bc,hl
;RAM:BE53 1A                          ld      a, (de)                                 ; attribute
       movb *de,a
;RAM:BE54 08                          ex      af, af'
       mov  af,af_
;RAM:BE55 13                          inc     de                                      ; ptr first character
       inc  de
loc_BE56:
;RAM:BE56 D9                          exx
       bl   @exx
;RAM:BE57 E1                          pop     hl                                      ; HL = Y,X
       dect sp
       mov  *sp,hl
;RAM:BE58 D5                          push    de
       mov  de,*sp+
;RAM:BE59 CD 48 D8                    call    calc_attrib_addr
       bl   @calc_attrib_addr
;RAM:BE5C 6B                          ld      l, e
;RAM:BE5D 62                          ld      h, d                                    ; HL = attribute memory address
       mov  de,hl
;RAM:BE5E D1                          pop     de
       dect sp
       mov  *sp,de
loc_BE5F:
;RAM:BE5F D9                          exx
       bl   @exx
;RAM:BE60 1A                          ld      a, (de)                                 ; next character
       movb *de,a
;RAM:BE61 CB 7F                       bit     7, a                                    ; done?
;RAM:BE63 20 0D                       jr      NZ, loc_BE72                            ; yes, skip
       jlt  loc_BE72
;RAM:BE65 D5                          push    de
       mov  de,*sp+
;RAM:BE66 CD 7F BE                    call    print_8x8                               ; display a character
       bl   @print_8x8
;RAM:BE69 D1                          pop     de
       dect sp
       mov  *sp,de
;RAM:BE6A 13                          inc     de
       inc  de
;RAM:BE6B D9                          exx
       bl   @exx
;RAM:BE6C 08                          ex      af, af'
       mov  af_,af
;RAM:BE6D 77                          ld      (hl), a                                 ; store attribute
       bl   @set_attribute
;RAM:BE6E 2C                          inc     l                                       ; next attribute address
       ab   one,@l
;RAM:BE6F 08                          ex      af, af'
       mov  af,af_
;RAM:BE70 18 ED                       jr      loc_BE5F                                ; loop until message done
       jmp  loc_BE5F
* ---------------------------------------------------------------------------
loc_BE72:
;RAM:BE72 E6 7F                       and     #0x7F ; ''                             ; mask off end-of-message bit
       andi a,>7f00
;RAM:BE74 D5                          push    de
       mov  de,*sp+
;RAM:BE75 CD 7F BE                    call    print_8x8                               ; display a character
      bl   @print_8x8
;RAM:BE78 D1                          pop     de
       dect sp
       mov  *sp,de
;RAM:BE79 13                          inc     de
       inc  de
;RAM:BE7A D9                          exx
       bl   @exx
;RAM:BE7B 08                          ex      af, af'
       mov  af_,af
;RAM:BE7C 77                          ld      (hl), a                                 ; store attribute
       bl   @set_attribute
;RAM:BE7D D9                          exx
       bl   @exx
;RAM:BE7E C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function print_text_std_font
*
* =============== S U B R O U T I N E =======================================
*
print_8x8:
;RAM:BE7F C5                          push    bc
       mov  bc,*sp+
;RAM:BE80 D5                          push    de
       mov  de,*sp+
;RAM:BE81 E5                          push    hl
       mov  hl,*sp+
;RAM:BE82 6F                          ld      l, a
;RAM:BE83 26 00                       ld      h, #0                                   ; HL = character
       clr  hl
       movb a,@l
;RAM:BE85 29                          add     hl, hl
;RAM:BE86 29                          add     hl, hl
;RAM:BE87 29                          add     hl, hl                                  ; calculate offset into font data
       sla  hl,3
;RAM:BE88 ED 5B C7 5B                 ld      de, (gfxbase_8x8)
       mov  @gfxbase_8x8,de
;RAM:BE8C 19                          add     hl, de                                  ; calculate address of font data
       a    de,hl
;RAM:BE8D EB                          ex      de, hl                                  ; DE = font data
       mov  hl,de
;RAM:BE8E E1                          pop     hl
       dect sp
       mov  *sp,hl
;RAM:BE8F 06 08                       ld      b, #8                                   ; # bytes (lines) to display
       movb @b08h,b
loc_BE91:
;RAM:BE91 1A                          ld      a, (de)                                 ; get font data byte
;RAM:BE92 77                          ld      (hl), a                                 ; store in video/buffer memory
;RAM:BE93 13                          inc     de                                      ; next font data byte
       movb *de+,*hl
;RAM:BE94 C5                          push    bc
;RAM:BE95 01 E0 FF                    ld      bc, #0xFFE0                             ; next video/buffer line
;RAM:BE98 09                          add     hl, bc
;RAM:BE99 C1                          pop     bc
       ai   hl,-32
;RAM:BE9A 10 F5                       djnz    loc_BE91                                ; loop until done character
       sb   one,b
       jne  loc_BE91
;RAM:BE9C D1                          pop     de
       dect sp
       mov  *sp,de
;RAM:BE9D 01 01 01                    ld      bc, #0x101
;RAM:BEA0 09                          add     hl, bc                                  ; video/buffer address for next character
       ai   hl,>0101
;RAM:BEA1 C1                          pop     bc
       dect sp
       mov  *sp,bc
;RAM:BEA2 C9                          ret
       rt
*
* End of function print_8x8
*
* =============== S U B R O U T I N E =======================================
*
check_user_input:
       mov  r11,*sp+
;RAM:D022 3A C3 5B                    ld      a, (all_objs_in_cauldron)
;RAM:D025 4F                          ld      c, a
       movb @all_objs_in_cauldron,@c
;RAM:D026 3A C4 5B                    ld      a, (obj_dropping_into_cauldron)
       movb @obj_dropping_into_cauldron,a
;RAM:D029 B1                          or      c
       socb @c,a
;RAM:D02A 0E 00                       ld      c, #0
;RAM:D02C C2 11 D1                    jp      NZ, finished_input
       jeq  !
       szcb mone,@c
       b    @finished_input
;RAM:D02F 3A A4 5B                    ld      a, (user_input_method)
!      szcb mone,@c
       movb @user_input_method,a
;RAM:D032 0F                          rrca
       srl  a,1
;RAM:D033 E6 03                       and     #3                                      ; keybd/joystick bits only
       andi a,>0300
;RAM:D035 CA C8 D0                    jp      Z, keyboard
       jeq  keyboard
;RAM:D038 3D                          dec     a
       sb   one,a
;RAM:D039 28 3C                       jr      Z, kempston
       jeq  kempston
;RAM:D03B 3D                          dec     a
       sb   one,a
;RAM:D03C 28 5E                       jr      Z, cursor
       jeq  cursor
interface_ii:
;RAM:D03E 3E F7                       ld      a, #0xF7 ; '�'                         ; address interface ii joystick
;RAM:D040 CD F7 B5                    call    read_port                               ; read joystick
;RAM:D043 C5                          push    bc
;RAM:D044 06 05                       ld      b, #5                                   ; 5 bits to read
;RAM:D046
;RAM:D046             loc_D046:
;RAM:D046 1F                          rra
;RAM:D047 CB 11                       rl      c                                       ; reverse bit order
;RAM:D049 10 FB                       djnz    loc_D046                                ; loop thru all bits
;RAM:D04B 79                          ld      a, c
;RAM:D04C C1                          pop     bc
;RAM:D04D 4F                          ld      c, a                                    ; store joystick reading
;RAM:D04E 3E EF                       ld      a, #0xEF ; '�'                          ; 0,9,8,7,6
;RAM:D050 CD F7 B5                    call    read_port
;RAM:D053 B1                          or      c                                       ; add joystick bits
;RAM:D054 0E 00                       ld      c, #0
;RAM:D056 CB 47                       bit     0, a                                    ; 0/left???
;RAM:D058 28 02                       jr      Z, loc_D05C
;RAM:D05A CB D9                       set     3, c
;RAM:D05C
;RAM:D05C             loc_D05C:
;RAM:D05C CB 4F                       bit     1, a
;RAM:D05E 28 02                       jr      Z, loc_D062
;RAM:D060 CB D1                       set     2, c
;RAM:D062
;RAM:D062             loc_D062:
;RAM:D062 CB 57                       bit     2, a
;RAM:D064 28 02                       jr      Z, loc_D068
;RAM:D066 CB E1                       set     4, c
;RAM:D068
;RAM:D068             loc_D068:
;RAM:D068 CB 5F                       bit     3, a
;RAM:D06A 28 02                       jr      Z, loc_D06E
;RAM:D06C CB C9                       set     1, c
;RAM:D06E
;RAM:D06E             loc_D06E:
;RAM:D06E CB 67                       bit     4, a
;RAM:D070 28 02                       jr      Z, loc_D074
;RAM:D072 CB C1                       set     0, c
;RAM:D074
;RAM:D074             loc_D074:
;RAM:D074 C3 11 D1                    jp      finished_input
       b    @finished_input
* ---------------------------------------------------------------------------
kempston:
;RAM:D077 DB 1F                       in      a, (0x1F)
*      Read joystick using CRU
;      Note: r12=af_
       li   r12,>0024                 ; CRU address of the column decoder
       li   tmp0,>0600                  ; Column 6, i.e joystick #1
       ldcr tmp0,3                      ; Select it
       li   r12,>0006                 , Base CRU address for joystick 1
;RAM:D079 0E 00                       ld      c, #0
       szcb mone,@c
;RAM:D07B CB 47                       bit     0, a                                    ; right?
       tb   2
;RAM:D07D 28 02                       jr      Z, loc_D081
       jeq loc_D081
;RAM:D07F CB C9                       set     1, c                                    ; flag RIGHT
       socb @b02h,@c
loc_D081:
;RAM:D081 CB 4F                       bit     1, a                                    ; left?
       tb   1
;RAM:D083 28 02                       jr      Z, loc_D087
       jeq  loc_D087
;RAM:D085 CB C1                       set     0, c                                    ; flag LEFT
       socb @b01h,@c
loc_D087:
;RAM:D087 CB 57                       bit     2, a                                    ; down?
       tb   3
;RAM:D089 28 02                       jr      Z, loc_D08D
       jeq  loc_D08D
;RAM:D08B CB E1                       set     4, c                                    ; flag PICKUP/DROP
       socb @b10h,@c
loc_D08D:
;RAM:D08D CB 5F                       bit     3, a                                    ; up?
       tb   4
;RAM:D08F 28 02                       jr      Z, loc_D093
       jeq  loc_D093
;RAM:D091 CB D1                       set     2, c                                    ; flag FORWARD
       socb @b04h,@c
loc_D093:
;RAM:D093 CB 67                       bit     4, a                                    ; fire?
       tb   0
;RAM:D095 28 02                       jr      Z, loc_D099
       jeq  loc_D099
;RAM:D097 CB D9                       set     3, c                                    ; flag JUMP
       socb @b08h,@c
loc_D099:
;RAM:D099 C3 11 D1                    jp      finished_input
       b    @finished_input
* ---------------------------------------------------------------------------
cursor:
;RAM:D09C 0E 00                       ld      c, #0
;RAM:D09E 3E F7                       ld      a, #0xF7 ; '�'                          ; row 3
;RAM:D0A0 CD F7 B5                    call    read_port
;RAM:D0A3 CB 67                       bit     4, a                                    ; '5'?
;RAM:D0A5 28 02                       jr      Z, loc_D0A9
;RAM:D0A7 CB C1                       set     0, c
;RAM:D0A9
;RAM:D0A9             loc_D0A9:                                                       ; row 4
;RAM:D0A9 3E EF                       ld      a, #0xEF ; '�'
;RAM:D0AB CD F7 B5                    call    read_port
;RAM:D0AE CB 47                       bit     0, a                                    ; '0'?
;RAM:D0B0 28 02                       jr      Z, loc_D0B4
;RAM:D0B2 CB D9                       set     3, c
;RAM:D0B4
;RAM:D0B4             loc_D0B4:                                                       ; '7'?
;RAM:D0B4 CB 5F                       bit     3, a
;RAM:D0B6 28 02                       jr      Z, loc_D0BA
;RAM:D0B8 CB D1                       set     2, c
;RAM:D0BA
;RAM:D0BA             loc_D0BA:                                                       ; '8'?
;RAM:D0BA CB 57                       bit     2, a
;RAM:D0BC 28 02                       jr      Z, loc_D0C0
;RAM:D0BE CB C9                       set     1, c
;RAM:D0C0
;RAM:D0C0             loc_D0C0:                                                       ; '6'?
;RAM:D0C0 CB 67                       bit     4, a
;RAM:D0C2 28 4D                       jr      Z, finished_input
;RAM:D0C4 CB E1                       set     4, c
;RAM:D0C6 18 49                       jr      finished_input
* ---------------------------------------------------------------------------
keyboard:
;RAM:D0C8 3E FE                       ld      a, #0xFE ; '�'                          ; row 0 (SHIFT,Z,X,C,V)
;RAM:D0CA CD F7 B5                    call    read_port
;RAM:D0CD 0F                          rrca
;RAM:D0CE 4F                          ld      c, a
;RAM:D0CF E6 03                       and     #3
;RAM:D0D1 CB 39                       srl     c
;RAM:D0D3 CB 39                       srl     c
;RAM:D0D5 B1                          or      c
;RAM:D0D6 E6 03                       and     #3
;RAM:D0D8 4F                          ld      c, a
;RAM:D0D9 3E 7F                       ld      a, #0x7F ; ''                          ; row 7
;RAM:D0DB CD F7 B5                    call    read_port
;RAM:D0DE CB 4F                       bit     1, a                                    ; SYM SHIFT? (right)
;RAM:D0E0 28 02                       jr      Z, loc_D0E4                             ; no, skip
;RAM:D0E2 CB C9                       set     1, c                                    ; flag RIGHT
loc_D0E4:
;RAM:D0E4 CB 57                       bit     2, a                                    ; 'M'? (left)
;RAM:D0E6 28 02                       jr      Z, loc_D0EA                             ; no, skip
;RAM:D0E8 CB C1                       set     0, c                                    ; flag LEFT
loc_D0EA:
;RAM:D0EA CB 5F                       bit     3, a                                    ; 'N'? (right)
;RAM:D0EC 28 02                       jr      Z, loc_D0F0                             ; no, skip
;RAM:D0EE CB C9                       set     1, c                                    ; flag RIGHT
loc_D0F0:
;RAM:D0F0 CB 67                       bit     4, a                                    ; 'B'? (left)
;RAM:D0F2 28 02                       jr      Z, loc_D0F6
;RAM:D0F4 CB C1                       set     0, c                                    ; flag LEFT
loc_D0F6:
;RAM:D0F6 3E BD                       ld      a, #0xBD ; '�'                         ; row 1,6 (2nd row) A,S,F,G,G,H,J,K,L,ENTER (FORWARD)
;RAM:D0F8 CD F7 B5                    call    read_port
;RAM:D0FB 28 02                       jr      Z, loc_D0FF
;RAM:D0FD CB D1                       set     2, c                                    ; flag FORWARD
loc_D0FF:
;RAM:D0FF 3E DB                       ld      a, #0xDB ; '�'                         ; row 2,5 (1st row) QWERTYUIOP (JUMP)
;RAM:D101 CD F7 B5                    call    read_port
;RAM:D104 28 02                       jr      Z, loc_D108
;RAM:D106 CB D9                       set     3, c                                    ; flag JUMP
loc_D108:
;RAM:D108 3E E7                       ld      a, #0xE7 ; '�'                         ; row 3,4 (0-9) (PICKUP/DROP)
;RAM:D10A CD F7 B5                    call    read_port
;RAM:D10D 28 02                       jr      Z, finished_input
;RAM:D10F CB E1                       set     4, c                                    ; flag PICKUP/DROP
finished_input:
;RAM:D111 3E 7E                       ld      a, #0x7E ; '~'                          ; (3rd row) SHIFT,Z,X,C,V,SPACE,SYMSHIFT,M,N,B (LEFT/RIGHT)
;RAM:D113 CD F7 B5                    call    read_port
;RAM:D116 E6 1E                       and     #0x1E                                   ; Z,X,C,V,SYMSHIFT,M,N,B
;RAM:D118 C5                          push    bc
;RAM:D119 47                          ld      b, a
;RAM:D11A 3E 99                       ld      a, #0x99 ; '�'
;RAM:D11C CD F7 B5                    call    read_port
;RAM:D11F B0                          or      b
;RAM:D120 C1                          pop     bc
       li   tmp0,KEY_SP
       bl   @chkkey
;RAM:D121 28 02                       jr      Z, loc_D125
       jeq  loc_D125
;RAM:D123 CB E9                       set     5, c                                    ; flag PICKUP/DROP (directional)
       socb @b10h,@c
loc_D125:
;RAM:D125 79                          ld      a, c
       movb @c,a
;RAM:D126 32 B5 5B                    ld      (user_input), a
       movb a,@user_input
;RAM:D129 C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function check_user_input
*
* =============== S U B R O U T I N E =======================================
*
handle_pause:
       rt
;RAM:D50E 3E 7E                       ld      a, #0x7E ; '~'                          ; SPACE,SYMSHIFT,M,N,B
;RAM:D510 CD F7 B5                    call    read_port
;RAM:D513 CB 47                       bit     0, a                                    ; SPACE?
;RAM:D515 C8                          ret     Z                                       ; no, exit
;RAM:D516 E6 1E                       and     #0x1E                                   ; any other key?
;RAM:D518 C0                          ret     NZ                                      ; yes, exit
;RAM:D519
;RAM:D519             debounce_space_press:
;RAM:D519 3E 7E                       ld      a, #0x7E ; '~'
;RAM:D51B CD F7 B5                    call    read_port
;RAM:D51E CB 47                       bit     0, a                                    ; SPACE?
;RAM:D520 20 F7                       jr      NZ, debounce_space_press                ; yes, loop
;RAM:D522 CD A8 B4                    call    toggle_audio_hw_x24
;RAM:D525
;RAM:D525             wait_for_space:
;RAM:D525 3E 7E                       ld      a, #0x7E ; '~'
;RAM:D527 CD F7 B5                    call    read_port
;RAM:D52A CB 47                       bit     0, a                                    ; SPACE?
;RAM:D52C 28 F7                       jr      Z, wait_for_space                       ; no, loop
;RAM:D52E
;RAM:D52E             debounce_space_release:
;RAM:D52E 3E 7E                       ld      a, #0x7E ; '~'
;RAM:D530 CD F7 B5                    call    read_port
;RAM:D533 CB 47                       bit     0, a                                    ; SPACE?
;RAM:D535 20 F7                       jr      NZ, debounce_space_release              ; no, loop
;RAM:D537 C3 A8 B4                    jp      toggle_audio_hw_x24
;RAM:D537             ; End of function handle_pause
;RAM:D537
* ---------------------------------------------------------------------------

;RAM:B5F7             ; =============== S U B R O U T I N E =======================================
;RAM:B5F7
;RAM:B5F7
;RAM:B5F7             read_port:
;RAM:B5F7 D3 FD                       out     (0xFD), a                               ; select upper address
;RAM:B5F9 DB FE                       in      a, (0xFE)                               ; read status
;RAM:B5FB 2F                          cpl                                             ; positive logic
;RAM:B5FC E6 1F                       and     #0x1F                                   ; mask off undefined bits
;RAM:B5FE C9                          ret
;RAM:B5FE             ; End of function read_port
;RAM:B5FE

*
* =============== S U B R O U T I N E =======================================
*
add_HL_A:
;RAM:D4F2 85                          add     a, l
;RAM:D4F3 6F                          ld      l, a
;RAM:D4F4 7C                          ld      a, h
;RAM:D4F5 CE 00                       adc     a, #0
;RAM:D4F7 67                          ld      h, a
       clr  tmp0
       movb a,@r0lb
       a    tmp0,hl
;RAM:D4F8 C9                          ret
       rt
*
* End of function add_HL_A
*
;* =============== S U B R O U T I N E =======================================
* Set HL = DE x A
*
HL_equals_DE_x_A:
;RAM:D4F9 C5                          push    bc
;RAM:D4FA 21 00 00                    ld      hl, #0
;RAM:D4FD 06 08                       ld      b, #8
;RAM:D4FF
;RAM:D4FF             loc_D4FF:
;RAM:D4FF 29                          add     hl, hl
;RAM:D500 07                          rlca
;RAM:D501 30 01                       jr      NC, loc_D504
;RAM:D503 19                          add     hl, de
;RAM:D504
;RAM:D504             loc_D504:
;RAM:D504 10 F9                       djnz    loc_D4FF
;RAM:D506 C1                          pop     bc
       clr  tmp0
       movb a,@r0lb
       mpy  de,tmp0
       mov  tmp1,hl
;RAM:D507 C9                          ret
       rt
*
* End of function HL_equals_DE_x_A
*
* =============== S U B R O U T I N E =======================================
*
zero_DE:
;RAM:D508 AF                          xor     a
       clr  a
fill_DE:
;RAM:D509 12                          ld      (de), a
;RAM:D50A 13                          inc     de
       movb a,*de+
;RAM:D50B 10 FC                       djnz    fill_DE
       sb   one,b
       jne  fill_DE
;RAM:D50D C9                          ret
       rt
*
* End of function zero_DE
*
* =============== S U B R O U T I N E =======================================
*
; Note: only works with words on TI
clr_mem:
;RAM:D53A 1E 00                       ld      e, #0
clr_byte:
;RAM:D53C 73                          ld      (hl), e                                 ; zero location
;RAM:D53D 23                          inc     hl                                      ; next location
       clr  *hl+
;RAM:D53E 0B                          dec     bc
       dect  bc
;RAM:D53F 78                          ld      a, b
;RAM:D540 B1                          or      c                                       ; done?
;RAM:D541 20 F9                       jr      NZ, clr_byte                            ; no, loop
       jne  clr_byte
;RAM:D543 C9                          ret
       rt
*
* End of function clr_mem
*
* ---------------------------------------------------------------------------
* START OF FUNCTION CHUNK FOR clr_bitmap_memory
*
clr_bitmap_memory:
       mov  r11,*sp+
;RAM:D544 21 00 40                    ld      hl, #zx_vram                            ; screen memory
;RAM:D547 01 00 18                    ld      bc, #0x1800                             ; # bytes to clear
;RAM:D54A 18 EE                       jr      clr_mem
       li   hl,PTRNTB
       clr  de
       li   bc,>1800
       bl   @vdpwr
* Return
       dect sp
       mov  *sp,r11
       rt
* END OF FUNCTION CHUNK FOR clr_bitmap_memory
*
* =============== S U B R O U T I N E =======================================
*
clr_attribute_memory:
       mov  r11,*sp+
;RAM:D54C 21 00 58                    ld      hl, #zx_aram                            ; colour data
;RAM:D54F 01 00 03                    ld      bc, #0x300                              ; # bytes to clear
;RAM:D552 1E 46                       ld      e, #0x46 ; 'F'                          ; bright yellow on black
;RAM:D554 18 E6                       jr      clr_byte
       li   hl,COLRTB
       li   de,>b100                  ; bright yellow on black
       li   bc,>1800
       bl   @vdpwr
* Return
       dect sp
       mov  *sp,r11
       rt
*
* End of function clr_attribute_memory
*
* =============== S U B R O U T I N E =======================================
*
fill_attr:
       mov  r11,*sp+
;RAM:D556 21 00 58                    ld      hl, #zx_aram                            ; colour data
;RAM:D559 01 00 03                    ld      bc, #0x300                              ; # bytes to clear
;RAM:D55C 5F                          ld      e, a                                    ; attribute to set
;RAM:D55D 18 DD                       jr      clr_byte                                ; fill
       bl   @ti_color
       li   hl,COLRTB
       mov  af_,de
       li   bc,>1800
       bl   @vdpwr
*      Return
       dect sp
       mov  *sp,r11
       rt
*
* End of function fill_attr
*
* =============== S U B R O U T I N E =======================================
*
clear_scrn:
       mov  r11,*sp+
;RAM:D55F
;RAM:D55F AF                          xor     a                                       ; border colour BLACK, activate MIC
;RAM:D560 D3 FE                       out     (0xFE), a                               ; ULA
;RAM:D562 CD 4C D5                    call    clr_attribute_memory
       bl   @clr_attribute_memory
;RAM:D565 18 DD                       jr      clr_bitmap_memory
       bl   @clr_bitmap_memory
       dect sp
       mov  *sp,r11
       rt
*
* End of function clear_scrn
*
* =============== S U B R O U T I N E =======================================
*
clear_scrn_buffer:
;RAM:D567 01 00 18                    ld      bc, #0x1800                             ; # bytes to clear
       li   bc,>1800
;RAM:D56A 21 F3 D8                    ld      hl, #vidbuf                             ; screen buffer
       li   hl,vidbuf
;RAM:D56D 18 CB                       jr      clr_mem
       jmp  clr_mem
;RAM:D56D             ; End of function clear_scrn_buffer
*
* =============== S U B R O U T I N E =======================================
*
* copies from screen buffer to video memory
*
update_screen:
;RAM:D56F 21 F3 D8                    ld      hl, #vidbuf                             ; screen buffer
;RAM:D572 11 E0 57                    ld      de, # zx_vram+0x17E0                    ; last line of attribute memory
;RAM:D575 01 C0 20                    ld      bc, #0x20C0                             ; B=32 bytes, C=192 lines
;RAM:D578
;RAM:D578             loc_D578:
;RAM:D578 C5                          push    bc
;RAM:D579 D5                          push    de
;RAM:D57A E5                          push    hl
;RAM:D57B
;RAM:D57B             loc_D57B:
;RAM:D57B 7E                          ld      a, (hl)                                 ; source byte
;RAM:D57C 12                          ld      (de), a                                 ; copy to destination
;RAM:D57D 36 00                       ld      (hl), #0                                ; wipe source byte
;RAM:D57F 23                          inc     hl                                      ; next source location
;RAM:D580 1C                          inc     e                                       ; next destination location
;RAM:D581 10 F8                       djnz    loc_D57B                                ; loop for a line
;RAM:D583 E1                          pop     hl                                      ; source - start of line
;RAM:D584 01 20 00                    ld      bc, #32
;RAM:D587 09                          add     hl, bc                                  ; next line
;RAM:D588 D1                          pop     de                                      ; last line of attribute memory
;RAM:D589 15                          dec     d
;RAM:D58A 7A                          ld      a, d
;RAM:D58B 2F                          cpl
;RAM:D58C E6 07                       and     #7
;RAM:D58E 20 0A                       jr      NZ, loc_D59A
;RAM:D590 7B                          ld      a, e
;RAM:D591 D6 20                       sub     #32
;RAM:D593 5F                          ld      e, a
;RAM:D594 38 04                       jr      C, loc_D59A
;RAM:D596 7A                          ld      a, d
;RAM:D597 C6 08                       add     a, #8
;RAM:D599 57                          ld      d, a                                    ; add 2K
;RAM:D59A
;RAM:D59A             loc_D59A:                                                       ; byte, line counter
;RAM:D59A C1                          pop     bc
;RAM:D59B 0D                          dec     c                                       ; dec line counter
;RAM:D59C 20 DA                       jr      NZ, loc_D578                            ; loop through all lines
       lwpi wrksp2
       li   r0,PTRNTB
       bl   @vwad
       li   r0,VDPWD
       li   r1,vidbuf+>1800-32
       li   r2,24
updscr1:
       li   r3,32
       mov  r1,r5
       s    r3,r1
       mov  r1,r6
       s    r3,r1
       mov  r1,r7
       s    r3,r1
       mov  r1,r8
       s    r3,r1
       mov  r1,r9
       s    r3,r1
       mov  r1,r10
       s    r3,r1
       mov  r1,r11
       s    r3,r1
       mov  r1,r12
       s    r3,r1
updscr2:
       movb *r5+,*r0
       movb *r6+,*r0
       movb *r7+,*r0
       movb *r8+,*r0
       movb *r9+,*r0
       movb *r10+,*r0
       movb *r11+,*r0
       movb *r12+,*r0
       dec  r3
       jne  updscr2
       dec  r2
       jne  updscr1
       lwpi wrksp
;RAM:D59E C9                          ret
       rt
*
* End of function update_screen
*
* =============== S U B R O U T I N E =======================================
*
blit_2x8:
       mov  r11,*sp+
;RAM:C432 CD 26 D8                    call    calc_vram_addr            ; dest
       bl   @calc_vram_addr
;RAM:C435 CD 11 D8                    call    calc_vidbuf_addr          ; source
       bl   @calc_vidbuf_addr
;RAM:C438 69                          ld      l, c
;RAM:C439 60                          ld      h, b
       mov  bc,hl
;RAM:C43A 01 02 08                    ld      bc, #0x802
       li   bc,>0802
;RAM:C43D C3 7C D6                    jp      blit_to_screen
       bl    @blit_to_screen          ; cannot jump because blit_to_screen doesn't pop return address
*      Return
       dect sp
       mov  *sp,r11
       rt
*
* End of function blit_2x8
*
* =============== S U B R O U T I N E =======================================
*
* Copy a section of the video buffer to the screen
*
* HL=source
* DE=destination
* B=lines
* C=bytes/line
*
* Note that B and C are swapped compared to fill_window
*
blit_to_screen:
;RAM:D67C C5                          push    bc
;RAM:D67D D5                          push    de
;RAM:D67E E5                          push    hl
;RAM:D67F 06 00                       ld      b, #0
;RAM:D681 ED B0                       ldir
;RAM:D683 E1                          pop     hl
;RAM:D684 11 20 00                    ld      de, #32
;RAM:D687 19                          add     hl, de                                  ; next line
;RAM:D688 D1                          pop     de
;RAM:D689 15                          dec     d
;RAM:D68A 7A                          ld      a, d
;RAM:D68B 2F                          cpl
;RAM:D68C E6 07                       and     #7
;RAM:D68E 20 0A                       jr      NZ, loc_D69A
;RAM:D690 7B                          ld      a, e
;RAM:D691 D6 20                       sub     #0x20 ; ' '
;RAM:D693 5F                          ld      e, a
;RAM:D694 38 04                       jr      C, loc_D69A
;RAM:D696 7A                          ld      a, d
;RAM:D697 C6 08                       add     a, #8
;RAM:D699 57                          ld      d, a
;RAM:D69A             loc_D69A:                                                       ; done all lines?
;RAM:D69A C1                          pop     bc
;RAM:D69B 10 DF                       djnz    blit_to_screen                          ; no, loop
;RAM:D69D C9                          ret

       mov  de,@wrksp2                 ; Destination: de -> r0
       mov  hl,@wrksp2+2               ; Source: hl -> r1
       mov  bc,@wrksp2+4               ; Dimensions: bc -> r2
       lwpi wrksp2
       mov  r2,r3
       andi r2,>ff00                   ; Lines
       swpb r2
       andi r3,>00ff                   ; Bytes/line
       mov  r0,r4
       andi r4,7                       ; Number of lines into character row (n)
       ci   r4,7                       ; If n is 7 it's a full row
       jeq  blit1                      ; and we can skip adding more lines
       neg  r4                         ; -n
       ai   r4,7                       ; 7 - n extra lines
       a    r4,r2                      ; add extra lines
       sla  r4,5
       s    r4,r1                      ; Adjust source
blit1:
       andi r0,>FFF8                   ; Move dest to top of character row
       mov  r3,r4                      ; Copy number of bytes/line
       li   r15,vdpwd
blit2:
       bl   @vwad                      ; Set VDP write address
       li   r3,32
       mov  r1,r5
       a    r3,r1
       mov  r1,r6
       a    r3,r1
       mov  r1,r7
       a    r3,r1
       mov  r1,r8
       a    r3,r1
       mov  r1,r9
       a    r3,r1
       mov  r1,r10
       a    r3,r1
       mov  r1,r11
       a    r3,r1
       mov  r1,r12
       a    r3,r1
       mov  r4,r3                      ; Reset bytes/line counter
blit3:
       movb *r12+,*r15                 ; Output in reverse order
       movb *r11+,*r15
       movb *r10+,*r15
       movb *r9+,*r15
       movb *r8+,*r15
       movb *r7+,*r15
       movb *r6+,*r15
       movb *r5+,*r15

;       seto *r15
;       seto *r15
;       seto *r15
;       seto *r15
;       seto *r15
;       seto *r15
;       seto *r15
;       seto *r15

       dec  r3
       jne  blit3
       ai   r0,-256
       ai   r2,-8
       jgt  blit2
       lwpi wrksp
       rt
*
* End of function blit_to_screen
*
* =============== S U B R O U T I N E =======================================
*
* HL = starting location
* B = width (bytes)
* C = height (lines)
* A = attribute
*
* Note that line length is fixed at 32.
*
fill_window:
       mov  bc,tmp0
       swpb tmp0
       andi tmp0,>00ff                ; tmp0=width
       swpb bc
;RAM:C515 11 20 00                    ld      de, #32                                 ; Line length
       li   de,32
loc_C518:
;RAM:C518 C5                          push    bc
;RAM:C519 E5                          push    hl
       mov  tmp0,tmp1
loc_C51A:
;RAM:C51A 77                          ld      (hl), a                                 ; set byte
;RAM:C51B 23                          inc     hl                                      ; next location
       movb a,*hl+
;RAM:C51C 10 FC                       djnz    loc_C51A                                ; loop for 1 line
       dec  tmp1
       jne  loc_C51A
;RAM:C51E E1                          pop     hl
;RAM:C51F 19                          add     hl, de                                  ; next line
       s    tmp0,hl
       a    de,hl
;RAM:C520 C1                          pop     bc
;RAM:C521 0D                          dec     c                                       ; done all lines?
       sb   one,b
;RAM:C522 20 F4                       jr      NZ, loc_C518                            ; no, loop
       jne  loc_C518
;RAM:C524 C9                          ret
       rt
*
* End of function fill_window
*
*=============== S U B R O U T I N E =======================================
*
build_lookup_tbls:
*
* Build a look-up table of values (0-255) shifted left 1-7 bits
* $F200 - $FFFF
* Each shifted byte is stored as a word.
* $100 entries x 2 bytes/entry * 7 = $e00 bytes
*
;RAM:D69E 2E 00                       ld      l, #0
;RAM:D6A0
loc_D6A0:
;RAM:D6A0 16 00                       ld      d, #0
;RAM:D6A2 5D                          ld      e, l
;RAM:D6A3 26 FF                       ld      h, #0xFF
;RAM:D6A5 06 07                       ld      b, #7
;RAM:D6A7
loc_D6A7:
;RAM:D6A7 CB 23                       sla     e
;RAM:D6A9 CB 12                       rl      d
;RAM:D6AB 7B                          ld      a, e
;RAM:D6AC 2F                          cpl
;RAM:D6AD 77                          ld      (hl), a
;RAM:D6AE 25                          dec     h
;RAM:D6AF 7A                          ld      a, d
;RAM:D6B0 2F                          cpl
;RAM:D6B1 77                          ld      (hl), a
;RAM:D6B2 25                          dec     h
;RAM:D6B3 10 F2                       djnz    loc_D6A7
;RAM:D6B5 2C                          inc     l
;RAM:D6B6 20 E8                       jr      NZ, loc_D6A0
*
* Build a look-up table of bit-reversed bytes (0-255)
* $F100 - $F1FF
* $100 entries x 1 byte/entry = $100 bytes
*
;RAM:D6B8 21 00 F1                    ld      hl, #0xF100
       li   hl,reverse_bytes_lookup_table
loc_D6BB:
;RAM:D6BB 55                          ld      d, l                                    ; byte offset from $F100
       movb @l,d
;RAM:D6BC 06 08                       ld      b, #8                                   ; 8 bits
       movb @b08h,b
       szcb mone,de_
loc_D6BE:
;RAM:D6BE CB 3A                       srl     d
;RAM:D6C0 CB 13                       rl      e                                       ; reverse bits
       srl  de_,1
       sla  d,1
       jnc  !
       socb @b80h,de_
;RAM:D6C2 10 FA                       djnz    loc_D6BE                                ; loop all bits
!      sb   one,b
       jne  loc_D6BE
;RAM:D6C4 73                          ld      (hl), e                                 ; store
       movb de_,*hl
;RAM:D6C5 2C                          inc     l                                       ; next index/location
       ab   one,@l
;RAM:D6C6 20 F3                       jr      NZ, loc_D6BB                            ; loop 256 bytes
       jne  loc_D6BB
;RAM:D6C8 C9                          ret
       rt
*
* End of function build_lookup_tbls
*
* =============== S U B R O U T I N E =======================================
*
calc_2d_info:
       mov  r11,*sp+
;RAM:CD33 CD C9 D6                    call    calc_pixel_XY
       bl   @calc_pixel_XY
;RAM:CD36 CD EF D6                    call    flip_sprite
       bl   @flip_sprite
;RAM:CD39 DD 7E 1A                    ld      a, 26(ix)                               ; pixel X
       movb @26(ix),a
;RAM:CD3C E6 07                       and     #7                                      ; bit offset
       andi a,>0700
       movb a,tmp0                    ; preserve flags
;RAM:CD3E 1A                          ld      a, (de)                                 ; ptr sprite data (width)
;RAM:CD3F 13                          inc     de                                      ; ptr height
       movb *de+,a
;RAM:CD40 28 01                       jr      Z, loc_CD43
       movb tmp0,tmp0
       jeq  loc_CD43
;RAM:CD42 3C                          inc     a
       ab   one,a
loc_CD43:
;RAM:CD43 E6 0F                       and     #0xF
       andi a,>0f00
;RAM:CD45 DD 77 18                    ld      24(ix), a                               ; sprite data width (bytes)
       movb a,@24(ix)
;RAM:CD48 1A                          ld      a, (de)
       movb *de,a
;RAM:CD49 DD 77 19                    ld      25(ix), a                               ; sprite data height
       movb a,@25(ix)
;RAM:CD4C C9                          ret
       dect sp
       mov  *sp,r11
       b    *r11
*
* End of function calc_2d_info
*
* =============== S U B R O U T I N E =======================================
*
* Calculate 2D coordinates from 3D coordinates
*
calc_pixel_XY:
;RAM:D6C9 DD 7E 01                    ld      a, 1(ix)                                ; X
       movb @1(ix),a
;RAM:D6CC DD 86 02                    add     a, 2(ix)                                ; add Y
       ab   @2(ix),a
;RAM:D6CF D6 80                       sub     #128
       sb   @b80h,a
;RAM:D6D1 DD 86 12                    add     a, 18(ix)                               ; add pixel_x_adj
       ab   @18(ix),a
;RAM:D6D4 DD 77 1A                    ld      26(ix), a                               ; pixel X
       movb a,@26(ix)
;RAM:D6D7 DD 7E 02                    ld      a, 2(ix)                                ; Y
       movb @2(ix),a
;RAM:D6DA DD 96 01                    sub     1(ix)                                   ; subtract X
       sb   @1(ix),a
;RAM:D6DD C6 80                       add     a, #128
       ab   @b80h,a
;RAM:D6DF CB 3F                       srl     a
       srl  a,1
;RAM:D6E1 DD 86 03                    add     a, 3(ix)                                ; Z
       ab   @3(ix),a
;RAM:D6E4 D6 68                       sub     #104
       sb   @b68h,a
;RAM:D6E6 DD 86 13                    add     a, 19(ix)                               ; pixel_y_adj
       ab   @19(ix),a
;RAM:D6E9 DD 77 1B                    ld      27(ix), a                               ; pixel Y
       movb a,@27(ix)
;RAM:D6EC FE C0                       cp      #192                                    ; bottom line of screen?
       cb   a,@bc0h ; This does not set carry on the TI if out of screen, but JHE should work
;RAM:D6EE C9                          ret
       rt
* End of function calc_pixel_XY
*
* =============== S U B R O U T I N E =======================================
*
* Flips sprite data (H,V) if required in-place
*
flip_sprite:
       mov  r11,*sp+
;RAM:D6EF DD 6E 00                    ld      l, 0(ix)                                ; sprite index
       movb *ix,@l
;RAM:D6F2 26 00                       ld      h, #0
       szcb mone,h
;RAM:D6F4 29                          add     hl, hl                                  ; word offset
       a    hl,hl
;RAM:D6F5 01 12 71                    ld      bc, #sprite_tbl
       li   bc,sprite_tbl
;RAM:D6F8 09                          add     hl, bc                                  ; sprite table entry
       a    bc,hl
;RAM:D6F9 5E                          ld      e, (hl)                                 ; little endian!
;RAM:D6FA 23                          inc     hl
;RAM:D6FB 56                          ld      d, (hl)                                 ; DE = sprite address
       mov  *hl,de
;RAM:D6FC 1A                          ld      a, (de)                                 ; width
       movb *de,a
;RAM:D6FD A7                          and     a                                       ; null sprite?
;RAM:D6FE C2 65 D8                    jp      NZ, vflip_sprite_data                   ; no, skip
       jeq  !
       b    @vflip_sprite_data
;RAM:D701 33                          inc     sp
;RAM:D702 33                          inc     sp                                      ; exit from caller
!      dect sp                                                                        ; do not return to print_sprite
                                                                                      ; but to the caller of print_sprite
;RAM:D703 C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function flip_sprite
*
* =============== S U B R O U T I N E =======================================
*
multiple_print_sprite:
       mov  r11,*sp+
multiple_print_sprite_loop:
;RAM:BEE4 C5                          push    bc
       mov  bc,*sp+
;RAM:BEE5 D5                          push    de
       mov  de,*sp+
;RAM:BEE6 E5                          push    hl
       mov  hl,*sp+
;RAM:BEE7 CD 18 D7                    call    print_sprite
       bl   @print_sprite
;RAM:BEEA E1                          pop     hl
       dect sp
       mov  *sp,hl
;RAM:BEEB D1                          pop     de
       dect sp
       mov  *sp,de
;RAM:BEEC C1                          pop     bc
       dect sp
       mov  *sp,bc
;RAM:BEED DD 7E 1A                    ld      a, 26(ix)                               ; pixel X
       movb @26(ix),a
;RAM:BEF0 83                          add     a, e                                    ; add offset
       ab   @e,a
;RAM:BEF1 DD 77 1A                    ld      26(ix), a                               ; store new pixel X
       movb a,@26(ix)
;RAM:BEF4 DD 7E 1B                    ld      a, 27(ix)                               ; pixel Y
       movb @27(ix),a
;RAM:BEF7 82                          add     a, d                                    ; add offset
       ab   d,a
;RAM:BEF8 DD 77 1B                    ld      27(ix), a                               ; store new pixel Y
       movb a,@27(ix)
;RAM:BEFB 10 E7                       djnz    multiple_print_sprite                   ; loop though all sprites
       sb   one,b
       jne  multiple_print_sprite_loop
;RAM:BEFD C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function multiple_print_sprite
*
* =============== S U B R O U T I N E =======================================
*
transfer_sprite_and_print:
       mov  r11,*sp+
;RAM:D24C CD 37 D2                    call    transfer_sprite                         ; copy to scratchpad
transfer_sprite_and_print_1:
       bl   @transfer_sprite
;RAM:D24F E5                          push    hl
       mov  hl,*sp+
;RAM:D250 CD 18 D7                    call    print_sprite
       bl   @print_sprite
;RAM:D253 E1                          pop     hl
       dect sp
       mov  *sp,hl
;RAM:D254 C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* End of function transfer_sprite_and_print
*
* =============== S U B R O U T I N E =======================================
*
transfer_sprite:
;RAM:D237 7E                          ld      a, (hl)                                 ; sprite index
;RAM:D238 23                          inc     hl
       movb *hl+,a
;RAM:D239 DD 77 00                    ld      0(ix), a                                ; store sprite index
       movb a,*ix
;RAM:D23C 7E                          ld      a, (hl)                                 ; flags
;RAM:D23D 23                          inc     hl
       movb *hl+,a
;RAM:D23E DD 77 07                    ld      7(ix), a                                ; store flags
       movb a,@7(ix)
;RAM:D241 7E                          ld      a, (hl)                                 ; X
;RAM:D242 23                          inc     hl
       movb *hl+,a
;RAM:D243 DD 77 1A                    ld      26(ix), a                               ; pixel X
       movb a,@26(ix)
;RAM:D246 7E                          ld      a, (hl)                                 ; Y
;RAM:D247 23                          inc     hl
       movb *hl+,a
;RAM:D248 DD 77 1B                    ld      27(ix), a                               ; pixel Y
       movb a,@27(ix)
;RAM:D24B C9                          ret
       rt
*
* End of function transfer_sprite
*
* =============== S U B R O U T I N E =======================================
*
calc_pixel_XY_and_render:
       mov  r11,*sp+
;RAM:D704 DD 7E 00                    ld      a, 0(ix)                                ; graphic no.
       movb *ix,a
;RAM:D707 FE 01                       cp      #1                                      ; flagged as ???
       cb   a,one
;RAM:D709 20 05                       jr      NZ, loc_D710                            ; no, continue
       jne  loc_D710
;RAM:D70B DD 36 00 00                 ld      0(ix), #0                               ; set to null
       szcb mone,*ix
;RAM:D70F C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* ---------------------------------------------------------------------------
*
loc_D710:
;RAM:D710 DD CB 07 A6                 res     4, 7(ix)                                ; flag don't draw
       szcb @b10h,@7(ix)
;RAM:D714 CD C9 D6                    call    calc_pixel_XY
       bl   @calc_pixel_XY
;RAM:D717 D0                          ret     NC                                      ; off bottom of screen, skip
       jl   print_sprite_1            ; if y position lower than 192
*      Else return
       dect sp
       mov  *sp,r11
       rt
*
* End of function calc_pixel_XY_and_render
*
* ix: holds the object address
*
print_sprite:
       mov  r11,*sp+
;RAM:D718 CD EF D6                    call    flip_sprite
print_sprite_1:
       bl   @flip_sprite              ; now de holds the sprite address
;RAM:D71B DD 7E 1A                    ld      a, 26(ix)                               ; pixel X
       movb @26(ix),a
;RAM:D71E E6 07                       and     #7                                      ; bit offset?
       andi a,>0700
;RAM:D720 28 4D                       jr      Z, loc_D76F                             ; no, skip
       jeq  loc_D76F
*      Calculate bit shift lookup table address
*      Not doing this on the TI, using shifts instead
;RAM:D722 07                          rlca                                            ; 0x02, 0x04, ..., 0x0e
;RAM:D723 E6 0E                       and     #0xE                                    ; necessary?
;RAM:D725 F6 F0                       or      #0xF0 ; '�'                            ; 0xf2, 0xf4, ..., 0xfe
;RAM:D727 67                          ld      h, a                                    ; hl = bit shift lookup table address
;RAM:D728 1A                          ld      a, (de)                                 ; sprite width
;RAM:D729 13                          inc     de
*
*      Setup shifts
       movb @b08h,b                   ; 8
       sb a,b                         ; 8 - offset
       sla  b,4                       ; Move bit offset shift into place for SLA instruction
       andi b,>f000
       sla  a,4
       andi a,>f000
       movb @bf0h,h
       szcb h,@shift_pattern_1+1
       socb b,@shift_pattern_1+1
       szcb h,@shift_mask_1+1
       socb b,@shift_mask_1+1
       szcb h,@shift_pattern_2+1
       socb a,@shift_pattern_2+1
       szcb h,@shift_mask_2+1
       socb a,@shift_mask_2+1
*
       movb *de+,a
;RAM:D72A E6 07                       and     #7
       andi a,>0700
;RAM:D72C 3C                          inc     a                                       ; width + 1
       ab   one,a
;RAM:D72D 47                          ld      b, a                                    ; keep width+1
       movb a,b
;RAM:D72E DD 77 18                    ld      24(ix), a                               ; store width_bytes
       movb a,@24(ix)
;RAM:D731 3D                          dec     a                                       ; width  (1, 2, 3, 4, 5)
       sb   one,a
;RAM:D732 E6 07                       and     #7                                      ; mod 8
;RAM:D734 87                          add     a, a                                    ; multiply by 16
;RAM:D735 87                          add     a, a
;RAM:D736 87                          add     a, a
;RAM:D737 87                          add     a, a                                    ; 16, 32, 48, 64, 80
;RAM:D738 ED 44                       neg                                             ; -16, -32, -48, -64, -80
;RAM:D73A C6 50                       add     a, #0x50 ; 'P'                          ; 64, 48, 32, 16, 0
*      On the TI we use a loop
       clr  tmp1
       movb a,@r1lb                   ; width
       mov  tmp1,tmp0                 ; copy width
       clr  a
loc_D73C:                                                                             ; self-modifying code
;RAM:D73C 32 AD D7                    ld      (loc_D7AC+1), a                         ; set jump offset
       movb a,@loc_D7AC+1
;RAM:D73F 78                          ld      a, b                                    ; width (or width+1)
       movb b,a
;RAM:D740 2F                          cpl                                             ; -(width+1)
       inv  a
;RAM:D741 C6 22                       add     a, #0x22 ; '"'                          ; 34-(width+1)=33-width
       ab   @b22h,a
;RAM:D743 32 01 D8                    ld      (loc_D800+1), a                         ; self-modifying code
       movb a,@loc_D800+3              ; patch LSB
;RAM:D746 1A                          ld      a, (de)                                 ; get sprite height
;RAM:D747 13                          inc     de
       movb *de+,a
;RAM:D748 DD 77 19                    ld      25(ix), a                               ; height_lines
       movb a,@25(ix)
;RAM:D74B DD 86 1B                    add     a, 27(ix)                               ; add Y
       ab   @27(ix),a
;RAM:D74E D6 C0                       sub     #192                                    ; off bottom of screen?
       cb   a,@bc0h
;RAM:D750 38 08                       jr      C, loc_D75A                             ; no, skip
       jl   loc_D75A
;RAM:D752 ED 44                       neg                                             ; -lines outside screen
;RAM:D754 DD 86 19                    add     a, 25(ix)                               ; height-lines outside screen
;RAM:D757 DD 77 19                    ld      25(ix), a                               ; store actual height_lines
       sb   @bc0h,a
       sb   a,@25(ix)
;RAM:D75A
loc_D75A:
;RAM:D75A DD 4E 1A                    ld      c, 26(ix)                               ; pixel X
       movb @26(ix),@c
;RAM:D75D DD 46 1B                    ld      b, 27(ix)                               ; pixel Y
       movb @27(ix),b
;RAM:D760 CD 11 D8                    call    calc_vidbuf_addr                        ; bc = address
       bl   @calc_vidbuf_addr
;RAM:D763 ED 73 A9 5B                 ld      (tmp_SP), sp                            ; store stack pointer
       mov  sp,@tmp_SP
;RAM:D767 EB                          ex      de, hl
;RAM:D768 F9                          ld      sp, hl                                  ; sp=source data address
;RAM:D769 EB                          ex      de, hl
       mov  de,sp
;RAM:D76A DD 7E 19                    ld      a, 25(ix)                               ; height_lines
       movb @25(ix),a
;RAM:D76D 18 3B                       jr      loc_D7AA
       jmp  loc_D7AA
;RAM:D76F             ; ---------------------------------------------------------------------------
* No pixel offset
loc_D76F:
;RAM:D76F 1A                          ld      a, (de)                                 ; sprite width
       movb *de+,a
;RAM:D770 13                          inc     de
;RAM:D771 E6 0F                       and     #0xF                                    ; mod 16
       andi a,>0f00
;RAM:D773 DD 77 18                    ld      24(ix), a                               ; width_bytes
       movb a,@24(ix)
;RAM:D776 47                          ld      b, a                                    ; keep width
       movb a,b
;RAM:D777 87                          add     a, a                                    ; multiply by 8
;RAM:D778 87                          add     a, a
;RAM:D779 87                          add     a, a                                    ; 8, 16, 24, 32, 40
       sla  a,3
;RAM:D77A ED 44                       neg                                             ; -8, -16, -24, -32, -40
       inv  a
       ab   one,a
;RAM:D77C D6 06                       sub     #6                                      ; -14, -20, -30, -38, -46
       sb   @b0ah,a                   ; 10 on the TI
* TMS9900 offsets are in words
       sra  a,1
;RAM:D77E 18 BC                       jr      loc_D73C                                ; to self modifying code
       jmp  loc_D73C
;RAM:D780             ; ---------------------------------------------------------------------------
* For sprites with no bit offset, 8 bytes per routine
* -- 1st byte --
;RAM:D780 D1                          pop     de                                      ; get pattern d and mask e
       mov  *sp+,de
;RAM:D781 0A                          ld      a, (bc)                                 ; get existing byte
;RAM:D782 2F                          cpl                                             ; invert
;RAM:D783 B3                          or      e                                       ; apply mask
;RAM:D784 2F                          cpl                                             ; invert
       szcb d,*bc
;RAM:D785 B2                          or      d                                       ; apply pattern
;RAM:D786 02                          ld      (bc), a                                 ; store
;RAM:D787 03                          inc     bc                                      ; next destination address
       socb  @e,*bc+
* -- 2nd byte --
;RAM:D788 D1                          pop     de
       mov  *sp+,de
;RAM:D789 0A                          ld      a, (bc)
;RAM:D78A 2F                          cpl
;RAM:D78B B3                          or      e
;RAM:D78C 2F                          cpl
       szcb d,*bc
;RAM:D78D B2                          or      d
;RAM:D78E 02                          ld      (bc), a
;RAM:D78F 03                          inc     bc
       socb  @e,*bc+
loc_D790:
* -- 3rd byte --
;RAM:D790 D1                          pop     de
       mov  *sp+,de
;RAM:D791 0A                          ld      a, (bc)
;RAM:D792 2F                          cpl
;RAM:D793 B3                          or      e
;RAM:D794 2F                          cpl
       szcb d,*bc
;RAM:D795 B2                          or      d
;RAM:D796 02                          ld      (bc), a
;RAM:D797 03                          inc     bc
       socb  @e,*bc+
* -- 4th byte --
;RAM:D798 D1                          pop     de
       mov  *sp+,de
;RAM:D799 0A                          ld      a, (bc)
;RAM:D79A 2F                          cpl
;RAM:D79B B3                          or      e
;RAM:D79C 2F                          cpl
       szcb d,*bc
;RAM:D79D B2                          or      d
;RAM:D79E 02                          ld      (bc), a
;RAM:D79F 03                          inc     bc
       socb  @e,*bc+
* -- 5th byte --
;RAM:D7A0 D1                          pop     de
       mov  *sp+,de
;RAM:D7A1 0A                          ld      a, (bc)
;RAM:D7A2 2F                          cpl
;RAM:D7A3 B3                          or      e
;RAM:D7A4 2F                          cpl
       szcb d,*bc
;RAM:D7A5 B2                          or      d
;RAM:D7A6 02                          ld      (bc), a
       socb  @e,*bc
* ---------------------------------------------------------------------------
;RAM:D7A7 C3 FF D7                    jp      loc_D7FF
       b    @loc_D7FF
* ---------------------------------------------------------------------------
loc_D7AA:
;RAM:D7AA 08                          ex      af, af'                                 ; save height
       mov  af,af_
;RAM:D7AB 0A                          ld      a, (bc)                                 ; get screen byte
       movb *bc,a
;RAM:D7AC                                                                             ; only required for forward jumps
loc_D7AC:
;RAM:D7AC 18 E2                       jr      loc_D790                                ; patched jump (forwards/backwards)
       jmp  loc_D790
* ---------------------------------------------------------------------------
* For sprites with bit offset
       mov  tmp0,tmp1
       clr  de
       clr  hl
plot_shifted_line:
       movb *sp+,@e                    ; get pattern
       movb *sp+,@l                    ; get mask
shift_pattern_1:
       sla  de,0                       ; Shift (8 - bit offset) pattern bits into MSB
shift_mask_1:
       sla  hl,0                       ; Actual shift values inserted by self-modiyfying code
       szcb d,*bc
       socb h,*bc+
       dec  tmp1
       jeq  plot_shifted_line_1
shift_pattern_2:
       sla  de,0                       ; Shift (bit offset) bits into MSB
shift_mask_2:
       sla  hl,0                       ; Actual shift values inserted by self-modiyfying code
       jmp  plot_shifted_line
plot_shifted_line_1:
       swpb de
       swpb hl
       szcb d,*bc
       socb h,*bc
* 16 bytes per routine
* -- 1st byte --                                                                      ; a holds the screen byte
;RAM:D7AE D1                          pop     de                                      ; get pattern d and mask e
;RAM:D7AF 6B                          ld      l, e                                    ; index of mask in byte shift table
;RAM:D7B0 A6                          and     (hl)                                    ; apply mask
;RAM:D7B1 6A                          ld      l, d                                    ; index of pattern in byte shift table
;RAM:D7B2 AE                          xor     (hl)                                    ; apply pattern inverted?
;RAM:D7B3 2F                          cpl                                             ; invert
;RAM:D7B4 02                          ld      (bc), a                                 ; store byte
;RAM:D7B5 03                          inc     bc                                      ; next source address
;RAM:D7B6 24                          inc     h                                       ; to second byte of shift table
;RAM:D7B7 6B                          ld      l, e                                    ; index of mask in byte shift table
;RAM:D7B8 0A                          ld      a, (bc)                                 ; get source byte
;RAM:D7B9 A6                          and     (hl)                                    ; apply mask
;RAM:D7BA 6A                          ld      l, d                                    ; index of pattern in byte shift table
;RAM:D7BB AE                          xor     (hl)                                    ; apply pattern inverted?
;RAM:D7BC 2F                          cpl                                             ; invert
;RAM:D7BD 25                          dec     h                                       ; back to first byte of shift table
* -- 2nd byte --
;RAM:D7BE D1                          pop     de
;RAM:D7BF 6B                          ld      l, e
;RAM:D7C0 A6                          and     (hl)
;RAM:D7C1 6A                          ld      l, d
;RAM:D7C2 AE                          xor     (hl)
;RAM:D7C3 2F                          cpl
;RAM:D7C4 02                          ld      (bc), a
;RAM:D7C5 03                          inc     bc
;RAM:D7C6 24                          inc     h
;RAM:D7C7 6B                          ld      l, e
;RAM:D7C8 0A                          ld      a, (bc)
;RAM:D7C9 A6                          and     (hl)
;RAM:D7CA 6A                          ld      l, d
;RAM:D7CB AE                          xor     (hl)
;RAM:D7CC 2F                          cpl
;RAM:D7CD 25                          dec     h
* -- 3rd byte --
;RAM:D7CE D1                          pop     de
;RAM:D7CF 6B                          ld      l, e
;RAM:D7D0 A6                          and     (hl)
;RAM:D7D1 6A                          ld      l, d
;RAM:D7D2 AE                          xor     (hl)
;RAM:D7D3 2F                          cpl
;RAM:D7D4 02                          ld      (bc), a
;RAM:D7D5 03                          inc     bc
;RAM:D7D6 24                          inc     h
;RAM:D7D7 6B                          ld      l, e
;RAM:D7D8 0A                          ld      a, (bc)
;RAM:D7D9 A6                          and     (hl)
;RAM:D7DA 6A                          ld      l, d
;RAM:D7DB AE                          xor     (hl)
;RAM:D7DC 2F                          cpl
;RAM:D7DD 25                          dec     h
* -- 4th byte --
;RAM:D7DE D1                          pop     de
;RAM:D7DF 6B                          ld      l, e
;RAM:D7E0 A6                          and     (hl)
;RAM:D7E1 6A                          ld      l, d
;RAM:D7E2 AE                          xor     (hl)
;RAM:D7E3 2F                          cpl
;RAM:D7E4 02                          ld      (bc), a
;RAM:D7E5 03                          inc     bc
;RAM:D7E6 24                          inc     h
;RAM:D7E7 6B                          ld      l, e
;RAM:D7E8 0A                          ld      a, (bc)
;RAM:D7E9 A6                          and     (hl)
;RAM:D7EA 6A                          ld      l, d
;RAM:D7EB AE                          xor     (hl)
;RAM:D7EC 2F                          cpl
;RAM:D7ED 25                          dec     h
* -- 5th byte --
;RAM:D7EE D1                          pop     de
;RAM:D7EF 6B                          ld      l, e
;RAM:D7F0 A6                          and     (hl)
;RAM:D7F1 6A                          ld      l, d
;RAM:D7F2 AE                          xor     (hl)
;RAM:D7F3 2F                          cpl
;RAM:D7F4 02                          ld      (bc), a
;RAM:D7F5 03                          inc     bc
;RAM:D7F6 24                          inc     h
;RAM:D7F7 6B                          ld      l, e
;RAM:D7F8 0A                          ld      a, (bc)
;RAM:D7F9 A6                          and     (hl)
;RAM:D7FA 6A                          ld      l, d
;RAM:D7FB AE                          xor     (hl)
;RAM:D7FC 2F                          cpl
;RAM:D7FD 25                          dec     h
* -- remaining bits --
;RAM:D7FE 02                          ld      (bc), a                                 ; store last byte
;RAM:D7FF
loc_D7FF:
* Next line
;RAM:D7FF 79                          ld      a, c
       movb @c,a
loc_D800:
;RAM:D800 C6 1E                       add     a, #0x1E                                ; patched line increment
;RAM:D802 4F                          ld      c, a
;RAM:D803 78                          ld      a, b
;RAM:D804 CE 00                       adc     a, #0                                   ; add carry
;RAM:D806 47                          ld      b, a
       ai   bc,>001e                  ; patched
;RAM:D807 08                          ex      af, af'                                 ; restore height
       mov  af_,af
;RAM:D808 3D                          dec     a
       sb   one,a
;RAM:D809 C2 AA D7                    jp      NZ, loc_D7AA                            ; line loop
       jne  loc_D7AA
;RAM:D80C ED 7B A9 5B                 ld      sp, (tmp_SP)                            ; restore stack pointer
       mov  @tmp_SP,sp
;RAM:D810 C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* =============== S U B R O U T I N E =======================================
*
* b: pixel Y
* c: pixel X
*
* Result in bc
*
calc_vidbuf_addr:
;RAM:D811 E5                          push    hl
;RAM:D812 CB 38                       srl     b                                       ; y >> 1, bit 0 to Carry
;RAM:D814 CB 19                       rr      c                                       ; Carry to bit 7, x >> 1
;RAM:D816 CB 38                       srl     b                                       ;
;RAM:D818 CB 19                       rr      c                                       ;
;RAM:D81A CB 38                       srl     b                                       ;
;RAM:D81C CB 19                       rr      c                                       ;
       srl  bc,3
;RAM:D81E 21 F3 D8                    ld      hl, #vidbuf                             ; bitmap buffer
;RAM:D821 09                          add     hl, bc                                  ; calculate bitmap memory address
;RAM:D822 4D                          ld      c, l
;RAM:D823 44                          ld      b, h                                    ; BC = bitmap memory address
       ai   bc,vidbuf
;RAM:D824 E1                          pop     hl
;RAM:D825 C9                          ret
       rt
*
* End of function calc_vidbuf_addr
*
* =============== S U B R O U T I N E =======================================
*
* b: pixel Y (0 is bottom line of screen)
* c: pixel X
*
* Result in de
*
; Given a Y coordinate stored in an 8-bit register:
;
; Y Coordinate bit layout (MSB to LSB):
; zzxx xnnn
;
; we can produce a 16-bit address in a register pair by placing these bits as follows:
;
; Register pair bit layout (R are the bits for the x-axis offset, 010 provides the base address $4000):
; 010z znnn xxxR RRRR
*
calc_vram_addr:
;RAM:D826 79                          ld      a, c
;RAM:D827 0F                          rrca
;RAM:D828 0F                          rrca
;RAM:D829 0F                          rrca
;RAM:D82A E6 1F                       and     #0x1F
;RAM:D82C 5F                          ld      e, a        ; 000 RRRRR
;RAM:D82D 78                          ld      a, b
;RAM:D82E 2F                          cpl
;RAM:D82F E6 07                       and     #7
;RAM:D831 08                          ex      af, af'     ; 00000 ~nnn
;RAM:D832 78                          ld      a, b
;RAM:D833 2F                          cpl
;RAM:D834 07                          rlca
;RAM:D835 07                          rlca
;RAM:D836 E6 E0                       and     #0xE0        ; ~xxx 00000
;RAM:D838 B3                          or      e            ; ~xxx RRRRR
;RAM:D839 5F                          ld      e, a
;RAM:D83A 78                          ld      a, b         ; zzxxxnnn
;RAM:D83B 2F                          cpl                  ; ~zzxxxnnn
;RAM:D83C 0F                          rrca
;RAM:D83D 0F                          rrca
;RAM:D83E 0F                          rrca                 ; ~nnnzzxxx
;RAM:D83F E6 18                       and     #0x18        ; 000 ~zz 000
;RAM:D841 57                          ld      d, a
;RAM:D842 08                          ex      af, af'      ; 00000 ~nnn
;RAM:D843 B2                          or      d            ; 000 ~zz ~nnn
;RAM:D844 C6 38                       add     a, #0x38     ; + 0011 1000 ?
;RAM:D846 57                          ld      d, a
;RAM:D847 C9                          ret
*      Reverse y
       li   tmp1,>bf00
       sb   b,tmp1
*      Calculate address E/A manual way
       movb tmp1,@e                    ; ????????yyyyyyyy
       sla  de,5                       ; ???yyyyyyyy00000
       socb tmp1,@e                    ; ???yyyyy???yyyyy
       andi de,>1f07                   ; 000yyyyy00000yyy
       mov  @c,@r0lb                   ; yyyyyyyyxxxxxxxx
       andi tmp0,7                     ; 0000000000000xxx
       ab   @c,@e                      ; 000yyyyyxxxxx???
       s    tmp0,de                    ; 000yyyyyxxxxxyyy
       rt
*
* End of function calc_vram_addr
*
* =============== S U B R O U T I N E =======================================
*
* h: pixel Y (0 is bottom line)
* l: pixel X
*
calc_attrib_addr:
;RAM:D848 E5                          push    hl
       mov  hl,*sp+
;RAM:D849 7C                          ld      a, h                                    ; Y
       movb h,a
;RAM:D84A 2F                          cpl
       inv  a
;RAM:D84B 67                          ld      h, a
       movb a,h
;RAM:D84C CB 3C                       srl     h                                       ; divide Y by 8
;RAM:D84E CB 3C                       srl     h
;RAM:D850 CB 3C                       srl     h
       movb h,tmp0
       srl  tmp0,3
       movb tmp0,h
;RAM:D852 CB 3C                       srl     h                                       ; divide by 8
;RAM:D854 CB 1D                       rr      l
;RAM:D856 CB 3C                       srl     h
;RAM:D858 CB 1D                       rr      l
;RAM:D85A CB 3C                       srl     h
;RAM:D85C CB 1D                       rr      l
       srl  hl,3
;RAM:D85E 11 00 57                    ld      de, # zx_vram+0x1700                    ; add base
       li   de,zx_vram+>1700
;RAM:D861 19                          add     hl, de
;RAM:D862 EB                          ex      de, hl
       a    hl,de
;RAM:D863 E1                          pop     hl
       dect sp
       mov  *sp,hl
;RAM:D864 C9                          ret
       rt
*
* End of function calc_attrib_addr
*
* ---------------------------------------------------------------------------
* DE = sprite data address
* START OF FUNCTION CHUNK FOR flip_sprite
*
vflip_sprite_data:                                                                    ; sprite data address
;RAM:D865 D5                          push    de
       mov  de,*sp+
;RAM:D866 1A                          ld      a, (de)                                 ; width
       movb *de,a
;RAM:D867 DD AE 07                    xor     7(ix)                                   ; same Vflip as stored?
       movb @7(ix),tmp0
       xor  tmp0,a
;RAM:D86A E6 80                       and     #0x80 ; '�'
       andi a,>8000
;RAM:D86C 28 34                       jr      Z, loc_D8A2                             ; yes, skip
       jeq  loc_D8A2
;RAM:D86E 1A                          ld      a, (de)                                 ; width
       movb *de,a
;RAM:D86F EE 80                       xor     #0x80 ; '�'                             ; toggle Vflip
       li   tmp0,>8000
       xor  tmp0,a
;RAM:D871 12                          ld      (de), a                                 ; store updated flag
       movb a,*de
;RAM:D872 07                          rlca                                            ; *2
       sla  a,1
;RAM:D873 E6 1E                       and     #0x1E
       andi a,>1e00
;RAM:D875 47                          ld      b, a                                    ; B = width x 2 (data+mask)
       movb a,b
;RAM:D876 13                          inc     de
       inc  de
;RAM:D877 1A                          ld      a, (de)                                 ; height
       movb *de,a
;RAM:D878 4F                          ld      c, a
       movb a,@c
;RAM:D879 13                          inc     de                                      ; sprite data
       inc  de
;RAM:D87A D5                          push    de
       mov  de,*sp+
;RAM:D87B 58                          ld      e, b
       movb b,@e
;RAM:D87C 16 00                       ld      d, #0                                   ; DE = width x 2
       szcb mone,d
;RAM:D87E CD F9 D4                    call    HL_equals_DE_x_A                        ; HL = width x 2 x height
       bl   @HL_equals_DE_x_A
;RAM:D881 D1                          pop     de                                      ; sprite data
       dect sp
       movb *sp,de
;RAM:D882 19                          add     hl, de                                  ; skip sprite data (including mask bytes)
       a    de,hl
;RAM:D883 EB                          ex      de, hl                                  ; DE=end of sprite data, HL=sprite data
       bl   @ex_de_hl
;RAM:D884 78                          ld      a, b                                    ; width x 2
       movb b,a
;RAM:D885 CD F2 D4                    call    add_HL_A                                ; HL=sprite data + width x 2
       bl   @add_HL_A
;RAM:D888 1B                          dec     de                                      ; last byte of sprite data
       dec  de
;RAM:D889 2B                          dec     hl                                      ; (height+1) x width x 2 - 1
       dec  hl
;RAM:D88A CB 39                       srl     c                                       ; height / 2
       movb @c,tmp0
       srl  tmp0,1
       movb tmp0,@c
loc_D88C:
;RAM:D88C C5                          push    bc                                      ; B=widthx2, C=height/2
       mov  bc,*sp+
vflip_sprite_line_pair:
;RAM:D88D 1A                          ld      a, (de)                                 ; sprite data byte from end
       movb *de,a
;RAM:D88E 4E                          ld      c, (hl)                                 ; sprite data from start
       movb *hl,@c
;RAM:D88F 77                          ld      (hl), a                                 ; store end data at start
       movb a,*hl
;RAM:D890 79                          ld      a, c
       movb @c,a
;RAM:D891 12                          ld      (de), a                                 ; store start data at end
       movb a,*de
;RAM:D892 2B                          dec     hl                                      ; next start byte
       dec  hl
;RAM:D893 1B                          dec     de                                      ; next end byte
       dec  de
;RAM:D894 10 F7                       djnz    vflip_sprite_line_pair                  ; flip sprite and mask data for line pair
       sb   one,b
       jne  vflip_sprite_line_pair
;RAM:D896 C1                          pop     bc
       dect sp
       mov  *sp,bc
;RAM:D897 78                          ld      a, b
       movb b,a
;RAM:D898 CD F2 D4                    call    add_HL_A
       bl   @add_HL_A
;RAM:D89B 78                          ld      a, b
       movb b,a
;RAM:D89C CD F2 D4                    call    add_HL_A                                ; next line
       bl   @add_HL_A
;RAM:D89F 0D                          dec     c                                       ; done all lines?
       sb   one,@c
;RAM:D8A0 20 EA                       jr      NZ, loc_D88C                            ; no, loop
       jne  loc_D88C
loc_D8A2:
;RAM:D8A2 D1                          pop     de
       dect sp
       mov  *sp,de
;RAM:D8A3 D5                          push    de                                      ; sprite data address
       mov  de,*sp+
;RAM:D8A4 1A                          ld      a, (de)                                 ; width (bytes)
       movb *de,a
;RAM:D8A5 DD AE 07                    xor     7(ix)                                   ; same Hflip as stored?
       movb @7(ix),tmp0
       xor  tmp0,a
;RAM:D8A8 E6 40                       and     #0x40 ; '@'
       andi a,>4000
;RAM:D8AA 28 30                       jr      Z, loc_D8DC                             ; yes, skip
       jeq  loc_D8DC
;RAM:D8AC 1A                          ld      a, (de)                                 ; width
       movb *de,a
;RAM:D8AD EE 40                       xor     #0x40 ; '@'                             ; toggle Hflip flag
       li   tmp0,>4000
       xor  tmp0,a
;RAM:D8AF 12                          ld      (de), a                                 ; store updated flag
       movb a,*de
;RAM:D8B0 E6 0F                       and     #0xF                                    ; width
       andi a,>0f00
;RAM:D8B2 47                          ld      b, a
       movb a,b
;RAM:D8B3 4F                          ld      c, a
       movb a,@c
;RAM:D8B4 13                          inc     de
       inc  de
;RAM:D8B5 1A                          ld      a, (de)                                 ; height
       movb *de,a
;RAM:D8B6 08                          ex      af, af'
       mov  af,tmp0
       mov  af_,af
       mov tmp0,af_
;RAM:D8B7 13                          inc     de                                      ; sprite data
       inc  de
;RAM:D8B8 EB                          ex      de, hl                                  ; HL=sprite data
       bl   @ex_de_hl
;RAM:D8B9 E5                          push    hl
       mov  hl,*sp+
;RAM:D8BA D9                          exx
       bl   @exx
;RAM:D8BB E1                          pop     hl                                      ; HL'=sprite data
       dect sp
       mov  *sp,hl
;RAM:D8BC 06 F1                       ld      b, #0xF1 ; '�'
       li   tmp0,reverse_bytes_lookup_table
       movb tmp0,b
;RAM:D8BE D9                          exx
       bl   @exx
loc_D8BF:
;RAM:D8BF D9                          exx
       bl   @exx
;RAM:D8C0 4E                          ld      c, (hl)                                 ; sprite data byte
       movb *hl+,@c
;RAM:D8C1 0A                          ld      a, (bc)                                 ; mirrored byte
       movb *bc,a
;RAM:D8C2 5F                          ld      e, a                                    ; store in e
       movb a,@e
;RAM:D8C3 23                          inc     hl
;      inc  hl                        ; already done
;RAM:D8C4 4E                          ld      c, (hl)                                 ; mask byte
       movb *hl+,@c
;RAM:D8C5 0A                          ld      a, (bc)                                 ; mirrored mask byte
       movb *bc,a
;RAM:D8C6 57                          ld      d, a                                    ; store in d
       movb a,d
;RAM:D8C7 23                          inc     hl
;      inc  hl                        ; already done
;RAM:D8C8 D5                          push    de                                      ; push mirrored
       mov  de,*sp+
;RAM:D8C9 D9                          exx
       bl   @exx
;RAM:D8CA 10 F3                       djnz    loc_D8BF
       sb   one,b
       jne  loc_D8BF
;RAM:D8CC 41                          ld      b, c
       movb @c,b
loc_D8CD:
;RAM:D8CD D1                          pop     de                                      ; pop mirrored
       dect sp
       mov  *sp,de
;RAM:D8CE 73                          ld      (hl), e                                 ; write date byte
;RAM:D8CF 23                          inc     hl
       movb @e,*hl+
;RAM:D8D0 72                          ld      (hl), d                                 ; write mask
;RAM:D8D1 23                          inc     hl
       movb d,*hl+
;RAM:D8D2 10 F9                       djnz    loc_D8CD
       sb   one,b
       jne  loc_D8CD
;RAM:D8D4 08                          ex      af, af'
       mov  af,tmp0
       mov  af_,af
       mov tmp0,af_
;RAM:D8D5 3D                          dec     a
       sb   one,a
;RAM:D8D6 28 04                       jr      Z, loc_D8DC
       jeq  loc_D8DC
;RAM:D8D8 08                          ex      af, af'
       mov  af,tmp0
       mov  af_,af
       mov tmp0,af_
;RAM:D8D9 41                          ld      b, c
       movb @c,b
;RAM:D8DA 18 E3                       jr      loc_D8BF
       jmp  loc_D8BF
* ---------------------------------------------------------------------------
loc_D8DC:
;RAM:D8DC D1                          pop     de
       dect sp
       mov  *sp,de
;RAM:D8DD C9                          ret
       dect sp
       mov  *sp,r11
       rt
*
* END OF FUNCTION CHUNK FOR vflip_sprite_data

*********************************************************************************
*
* TI-99/4 helper routines
*
*********************************************************************************

ti_99_4a_init:
       mov  r11,@STACK
       limi 0
       lwpi WRKSP
       li   sp,STACK+2
       movb @RNDSD,@rand_no
       li   one,>0100
       li   mone,>ff00
       bl   @gmode
       dect sp
       mov  *sp,r11
       rt

*********************************************************************************
*
* Set graphics mode
*
gmode:
       lwpi wrksp2
       clr  r0
       li   r1,vregs
       li   r2,8
gmode1:
       swpb r0
       movb *r1+,r0
       swpb r0
       bl   @vwtr                          ; Set register
       ai   r0,>0100
       dec  r2
       jne  gmode1
*      Setup name table for bitmap drawing
       li   r0, nametb
       bl   @vwad
       clr  r1
       li   r2,>300
gmode2:
       movb r1,@vdpwd
       ai   r1,>0100
       dec  r2
       jne  gmode2
*      Disable sprites
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       lwpi wrksp
       rt
*      VDP registers
vregs:
       byte >02                            ; Graphics II mode
       byte >e2                            ; 16K, display on, interrupt enabled
       byte nametb/>400                    ; Name table
       byte >ff                            ; Color table
       byte ptrntb/>800+>03                ; Pattern table
       byte spratb/>80                     ; Sprite attribute table
       byte sprptb/>800                    ; Sprite pattern table
       byte >01                            ; Backdrop color
*// gmode

*********************************************************************************
*
* HL = starting location in zx_aram
* A = attribute
*
set_attribute:
       mov  r11,*sp+
       mov  bc,*sp+
       li   bc,>0101
       bl   @fill_color_window
       dect sp
       mov  *sp,bc
       dect sp
       mov  *sp,r11
       rt
*// set_attribute

*********************************************************************************
*
* Fill color window
*
* HL = starting location in zx_aram
* B = width (bytes)
* C = height (lines)
* A = attribute
*
fill_color_window:
       mov  r11,*sp+
       bl   @ti_color
       mov  hl,@wrksp2                  hl -> r0
       movb af_,@wrksp2+2               af_ -> r1
       mov  bc,@wrksp2+4                bc -> r2
       lwpi wrksp2
       ai   r0,-zx_aram
       mov  r0,r3
       srl  r0,5                       ; Divide by 32 to get row
       swpb r0                         ; Multiply by 256, this is the row offset
       andi r3,>001f                   ; Column
       sla  r3,3                       ; Multiply by 8, this is the column offset
       a    r3,r0                      ; Add to row offset
       ai   r0,COLRTB
       mov  r2,r3
       swpb r2
       andi r2,>00ff
       andi r3,>00ff
       mov  r2,r4
       li   r5,VDPWD
fill_color_window_1:
       bl   @vwad
       mov  r4,r2
fill_color_window_2:
       movb r1,*r5
       movb r1,*r5
       movb r1,*r5
       movb r1,*r5
       movb r1,*r5
       movb r1,*r5
       movb r1,*r5
       movb r1,*r5
       dec  r2
       jne  fill_color_window_2
       ai   r0,256
       dec  r3
       jne  fill_color_window_1
       lwpi wrksp
       dect sp
       mov  *sp,r11
       rt
*// fill_color_window

*********************************************************************************
*
* Get TI-99 color from ZX Spectrum color
*
* a: Colour-byte FBPPPIII
*  - I - Ink colour (0-7)
*  - P - Paper colour (0-7)
*  - B - Bright (0-No, 1-Yes)
*  - F - Flash  (0-No, 1-Yes)
*
* On return af_ contains the TI color FFFFBBBB.
*
ti_color:
       movb a,@wrksp2
       lwpi wrksp2
       clr  r1
*      Foreground
       mov  r0,r2
       andi r2,>0700                   ; Foreground bits
       mov  r0,r3
       andi r3,>4000                   ; Bright bit
       srl  r3,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r1
       sla  r1,4
*      Background
       mov  r0,r2
       andi r2,>3800                   ; Background bits
       srl  r2,3
       soc  r3,r2
       swpb r2
       movb @tipal(r2),r3
       socb r3,r1
       lwpi wrksp
       movb @wrksp2+2,af_
       rt

* Spectrum palette
* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
* 8  Black,    9 Blue,    10 Red,      11 Magenta
* 12 Green,   13 Cyan,    14 Yellow,   15 White

* TI palette
* 0  Trans,    1 Black,    2 M Green,   3 L Green
* 4  D Blue,   5 L Blue,   6 D Red,     7 Cyan
* 8  M Red,    9 L Red,   10 D Yellow, 11 L Yellow
* 12 D Green, 13 Magenta, 14 Gray,     15 White

tipal  byte 1,4,6,13,12,7,10,14,1,5,8,13,2,7,11,15
* Not used: 3 L Green, 9 L Red
* Not available: D Cyan, D Magenta
*// ti_color

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
vdpwr:
       mov  hl,@wrksp2                 ; hl -> r0
       mov  de,@wrksp2+2               ; de -> r1
       mov  bc,@wrksp2+4               ; bc -> r2
       lwpi wrksp2
       bl   @vwad
       li   r0,vdpwd
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1,*r0
       dec  r2
       jne  vdpwr2
vdpwr3:
       lwpi wrksp
       rt
*// vdpwr

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       rt
*// vsbw

***************************************************************************
*
* Emulation of Z80 instructions
*
exx:
       mov  bc,tmp0
       mov  bc_,bc
       mov  tmp0,bc_
       mov  hl,tmp0
       mov  hl_,hl
       mov  tmp0,hl_
       mov  de,tmp0
       mov  de_,de
       mov  tmp0,de_
       rt

ex_de_hl:
       mov  de,tmp0
       mov  hl,de
       mov  tmp0,hl
       rt

ldir:
       movb *hl+,*de+
       dec  bc
       jne  ldir
       rt

* If the least significant four bits of A contain a non-BCD digit (i. e. it is greater than 9)
* or the H flag is set, then $06 is added to the register. Then the four most significant bits are checked.
* If this more significant digit also happens to be greater than 9 or the C flag is set, then $60 is added.
daa:
       mov  a,tmp0
       andi tmp0,>0f00
       cb   tmp0,@b09h
       jle  daa1
       ab   @b06h,a
daa1:
       mov  a,tmp0
       andi tmp0,>f000
       srl  tmp0,4
       cb   tmp0,@b09h
       jle  daa2
       ab   @b60h,a
daa2:
       rt

* Random number generator
ld_a_r:
       mov  @rand_no,tmp0
       li   tmp1,28643                  ; A prime number to multiply by
       mpy  tmp1,tmp0
       ai   tmp0,31873                  ; Add a prime number
       src  tmp0,7                      ; Shift to break odd/even pattern
       mov  tmp0,@rand_no
       movb tmp0,a
       rt
rand_no:
       data 0

***************************************************************************
*
* Check key
*
* tmp0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
*
chkkey:
;      Note: r12 = af_
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr tmp0,3                     ; Select column
       andi tmp0,>00ff
       mov  tmp0,r12                   ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// CHKKEY

*********************************************************************
*
* Byte constants
*
b00h   byte >00
b01h   byte >01
b02h   byte >02
b03h   byte >03
b04h   byte >04
b05h   byte >05
b06h   byte >06
b07h   byte >07
b08h   byte >08
b09h   byte >09
b0ah   byte >0a
b0ch   byte >0c
b0dh   byte >0d
b0eh   byte >0e
b10h   byte >10
b12h   byte >12
b14h   byte >14
b17h   byte >17
b1ah   byte >1a
b1fh   byte >1f
b20h   byte >20
b22h   byte >22
b28h   byte >28
b30h   byte >30
b37h   byte >37
b40h   byte >40
b47h   byte >47
b51h   byte >51
b58h   byte >58
b5ah   byte >5a
b5ch   byte >5c
b68h   byte >68
b60h   byte >60
b70h   byte >70
b78h   byte >78
b80h   byte >80
b8ch   byte >8c
ba0h   byte >a0
baeh   byte >ae
bb0h   byte >b0
bb8h   byte >b8
bbah   byte >ba
bbbh   byte >bb
bc0h   byte >c0
bc8h   byte >c8
bd0h   byte >d0
be1h   byte >e1
bf0h   byte >f0
bf1h   byte >f1
bfeh   byte >fe
bffh   byte >ff

*
* End of upper memory
*
